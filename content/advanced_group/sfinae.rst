SFINAE (для продвинутой группы по C++)
######################################

:date: 2020-05-04 00:00
:summary: SFINAE (для продвинутой группы по C++)
:status: published

.. default-role:: code
.. contents:: Содержание

Шаблоны и метапрограммирование
==============================

Одной из самых важных частей языка С++ являются шаблоны. Изначально шаблоны были введены в язык С++ для упрощения и предотвращения дублирования кода. Однако реальное применение шаблонов куда шире. Тот факт, что раскрытие шаблонов происходит на этапе компиляции, позволяет использовать их как средство построения абстракций нулевой стоимости (zero-cost abstraction) или применять для вычислений на этапе компиляции.

Метапрограммированием называют созданием программ, которые в результате своего выполнения порождают другие программы. Примером метапрограммирования в С++ могут служить шаблоны и директивы прекомпилятора. Фактически, в ходе компиляции программы ее исходный код преобразуется, а компилируется в машинный код уже результаты этого преобразования. Таким образом решается задача кодогенерации.

Зачастую в метопрограммировании возникает задача рефлексии (интроспекции). В большинстве языков программирования, рефлексия доступна на этапе выполнения программы. Однако, такой подход прямо противоречит философии языка С++ как языка, который должен предоставлять разработчику мощные инструменты для разработки, использование которых не должно замедлять исполнение программы. На самом деле, не всегда возможно построение какой-то абстракции без влияния на этап выполнения. Кроме того, часть возможностей языка несовместима с некоторыми выполняемыми компиляторами оптимизациями, что может приводить к появлению некорректно работающего кода (например, проблемы могут возникать из-за алиасинга и фокусов с указателями). В любом случае, в С++ нет, и, скорее всего, никогда не будет полноценной рефлексии на этапе выполнения (кроме того, высока вероятность того, что если оно и появится - его будут выключать при сборке так же, как сейчас выключают RTTI). Добавление в стандарт языка статической рефлексии (рефлексии на этапе компиляции) обсуждалось, однако было отложено как минимум до С++23. Тем не менее, существует ряд сторонних библиотек, которые реализуют эти возможности при помощи все тех же шаблонов и макросов. Стоит отметить, что использование метапрограммирования может значительно затруднить понимание и отладку кода, особенно для начинающих разработчиков, которые будут пользоваться написанной библиотекой, поэтому не стоит бездумно прибегать к нему (но и не стоит избегать его, когда оно позволяет упростить код).

SFINAE
======

Аббревиатура SFINAE расшифровывается как Substitution Failure Is Not An Error, неудавшаяся подстановка не является ошибкой. Это название отображает правило, по которому компилятор С++ обрабатывает перегруженные шаблонные функции или структуры. Правило гласит, что если компилятор не может рассчитать окончательные типы аргументов (раскрыть шаблон), то это не должно приводить к ошибке, компилятор должен проверить все остальные перегрузки. Ошибка возникает, если ни одна из перегрузок не подошла, или же наоборот подошло более одной перегрузки (в этом случае компилятор не может выбрать одну из них).

Это правило появилось в С++98. Первоначально его целью было избавить разработчика от проблем с компиляцией из-за совпадения имен используемых им классов с существующими где-то в используемых им библиотеках. На самом деле, стандарт С++ описывает множество случаев, когда не удается выполнить подстановку в одной из перегрузок, приводящих к ошибке (см. [1]), однако на практике обычно используются параметры шаблона или параметры функций. В случае, если нет никаких особых причин поступить иначе, лучше реализовывать SFINAE через параметр шаблона, а не через дополнительный параметр функции. В пользу этого выбора можно привести следующий аргумент: стандарт С++ гласит, что перегрузки функций, находящиеся в одной области видимости и отличающиеся лишь значением по умолчанию для параметров функции недопустимы. В случае же с классами использовать для SFINAE аргумент по умолчанию просто не удастся.

C++03
=====

Рассмотрим следующий код:

.. code :: c++

    template<typename T, typename U>                                                                                                                                                                                                       
    struct IsShiftable 
    {
        typedef char yes[1];
        typedef char no[2];
        
        template <std::size_t N>
        struct SFINAE {};
        
        template <typename F, typename O>
        static yes& Is(SFINAE<sizeof( *static_cast<F*>(NULL) << *static_cast<O*>(NULL) )>* = 0); 
        
        template <typename F, typename O>
        static no& Is(...);
        
        static const bool value = (sizeof(Is<T, U>(NULL)) == sizeof(yes));
    };

    struct Obj {};

    struct Ok
    {
        Ok& operator<<(Obj) { return *this; }
    };

    struct Nok {};

    int main()
    {
        std::cout << IsShiftable<Ok, Obj>::value << std::endl;
        
        std::cout << IsShiftable<Nok, Obj>::value << std::endl;
    }

Структура IsShiftable позволяет на этапе компиляции определить, существует ли у типа T operator<<, вторым операндом которого является значение типа U. Для этого в структуре есть перегруженная функция Is. Рассмотрим оба варианта этой функции. Первый вариант принимает на вход один аргумент со значением по умолчанию. Этот аргумент - это указатель на шаблонную структуру, в качестве параметра шаблона которой передается размер типа, который будет возвращен в результате применения operator<<, наличие которого мы пытаемся проверить. Второй вариант принимает на вход произвольное количество произвольных аргументов (variardic argument, см. [3]). Согласно правилам выбора перегрузок [4], этот вариант будет иметь самый низкий приоритет и будет выбран только если никакие другие не подойдут. 

Таким образом, если искомый оператор существует, то компилятор на этапе компиляции выведет нужный тип, размер которого станет параметром шаблона структуры SFINAE, то есть удастся вывести тип параметра для первой перегрузки функции Is<T, U>, используемой при вычислении константы value. Соответственно, тип возврата этой функции будет yes&, и константа value будет иметь значение true. Если же этот оператор не существует, то будет выбрана вторая перегрузка функции Is<T, U>, тип возврата выведен как no& и константа будет равна false.

С++11
=====

В C++11 был добавлен способ сделать то же самое несколько менее многословно:

.. code :: c++
    
    template<class T, class U, class = decltype(std::declval<T>() << std::declval<U>() )> 
    std::true_type  IsShiftable_(const T&, const U&);
    std::false_type IsShiftable_(...);

    template<class T, class U> using IsShiftable = decltype(IsShiftable_(std::declval<T>(), std::declval<U>()));

    struct Obj {};

    struct Ok
    {
        Ok& operator<<(Obj) { return *this; }
    };

    struct Nok {};

    int main()
    {
        std::cout << IsShiftable<Ok, Obj>::value << std::endl;
        
        std::cout << IsShiftable<Nok, Obj>::value << std::endl;
    }

Здесь вместо вложенных структур используется шаблонная функция, а также используются спецификатор decltype и появившийся в STL std::declval, принципиально же происходящее не изменилось. Также в C++11 в STL появилась структура enable_if<bool B, class T = void>, в которой определен тип type = T, если B == true (и нет этого определения если B == false). Эту структуру удобно использовать в качестве дополнительного аргумента шаблона:

.. code :: c++
    
    template <class T, class = typename std::enable_if<SomeCondition<T>::value>::type>
    int mySFINAEFunction(const T& arg) { /* ... */ }
    
Можно видеть, что компилятор сможет вывести все шаблонные типы для такой перегрузки, только если условие будет выполнено.

C++20
=====

В стандарте C++20 появилась поддержка концептов, нового способа сделать то же самое, но записать еще более явно. Почитать об этом можно тут [5][6]. К сожалению, ни один компилятор пока не поддерживает С++20 полностью [7], поэтому новый стандарт пока почти не используется.

Задание
=======

В задании на хеш-таблицы есть две секции тестов, проверяющие реализацию хеша для целочисленных типов и для классов с методом GetHash. Добавьте эти реализации в файл hash.h, определите макросы, которые проверяются в файле тестов директивами #ifdef. Хеш-таблица должна заработать без дополнительных модификаций.

Ссылки
======

1. https://en.cppreference.com/w/cpp/language/sfinae
2. https://en.cppreference.com/w/cpp/language/default_arguments
3. https://en.cppreference.com/w/cpp/language/variadic_arguments
4. https://en.cppreference.com/w/cpp/language/overload_resolution
5. https://en.cppreference.com/w/cpp/language/constraints
6. https://en.cppreference.com/w/cpp/concepts
7. https://en.cppreference.com/w/cpp/compiler_support
