Хеш-таблицы и хеширование (для продвинутой группы по C++)
#########################################################

:date: 2020-04-25 00:00
:summary: Хеш-таблицы и хеширование (для продвинутой группы по C++)
:status: draft

.. default-role:: code
.. contents:: Содержание

Хеш-функции
===========

Хеш-функцией называется функция, которая выполняет преобразование входных данных в битовую строку заранее известной длины. Результат применения хеш-функции ко входному значению называется хешем (хешом, хеш-суммой).

Важным свойством хеш-функции является то, что входные данные могут иметь произвольную длину. Поскольку эта длина может превышать длину хеша, то однозначного соответствия между входными данными и хешем нет и не может быть, это следует из принципа Дирихле. Ситуация, когда два рахличных набора входных данных имеют одинаковый хеш, называются коллизиями.

Пусть M -- множество возможных значений хеш-суммы, m -- его мощность. Хеш-функция H называется равномерной, если для произвольного значения x и произвольного k из множества значений функции вероятность того, что H(x)=k равна 1/m (то есть все значения хеша равновероятны). Универсальныим называется множество хеш-функций S мощности s, выполняющих отображение значений на одно и то же множество хешей M, называется универсальным, если для произвольной пары значений k, l количество функций H из множества S, таких, что H(k)=H(l) не превышает s/m. Иными словами, случайно выбранная хеш-функция из этого множества отображает эти значения в одну и ту же хеш-сумму с вероятностью, равной вероятности случайного совпадения хеш-сумм.

Задача хеширования имеет множество практических применений:

1. Контроль целостности данных. В этом случае данные хешируются получателем, и результат хеширования сверяется с предоставленным отправителем результатом;
2. Поиск дубликатов в наборе данных и быстрая проверка наличия данных в наборе;
3. Построение ассоциативных  массивов -- структур данных, в которых ключ не является числом;
4. Криптография.

Хеш-функции, используемые в криптографии -- это отдельный класс хеш-функций, на которые накладываются дополнительные ограничения (сложность поиска первого прообраза, сложность поиска второго прообраза, сложность к поиску коллизий, сложность к удлинению прообраза). Построение и анализ крипогрфических хеш-функций -- это сложные математические задачи (впрочем, как и все остальное в криптографии).

Простым примером хеш-функции является функция вида H(x) = (Ax + B) mod P, где P - простое число, задающее пространство значений хеша, A и B - положительные целочисленные константы. На практике функции такого типа могут применяться для чисел известной длины, но плохо подходят для данных произвольного размера.

Хеш-таблицы и разрешение коллизий
=================================

Хеш-таблица -- это структура данных, которая позволяет хранить пары ключ-значение, где ключи являются значениями хешируемого типа данных. Внутри хеш-таблицы для доступа к данным используются хеши ключей. Из этого следует, что для корректной работы хеш-таблицы необходимы механизмы разрешения коллизий.

Будем называть ячейку массива, который хранится внутри хеш-таблицы ячейкой таблицы или бакетом.

Метод цепочек
-------------

При использовании метода цепочек, в ячейках хеш-таблицы хранятся не сами значения, соответствующие ключам, а связные списки. Каждый элемент этих списков содержит фактическое значение ключа и значение, которое ему соответствует. В случае обнаружения коллизии, новое значение и соответствующий ему ключ просто дописываются в конец этого связного списка. При поиске значения по ключу происходит последовательный перебор всех элементов списка в соответствующей хеш-сумме ключа ячейке. Перебор продолжается до тех пор, пока не будет найдено значение, соответствующее искомому ключу, или пока список не закончится (в этом случае значение, соответствующее ключу, в таблице отсутствует). Вместо связного списка, в ячейке может храниться другая структура данных, но использование альтернативных структур или налагает дополнительные ограничения на ключ (например, использование дерева поиска требует, чтобы на множестве ключей был задан линейный порядок), или не дает выигрыша в производительности.

Метод открытой адресации
------------------------

При использовании метода открытой адресации в ячейках таблицы хранятся непосредственно пары ключ-значение. При попытке вставки, если соответствующая ячейка уже занята, начинается просмотр следующих ячек в определенном порядке (в простейшем случае -- просто следующих ячеек таблицы, но часто используются более сложные методы, например основанные на использовании второй хеш-функции). Этот просмотр продолжается до тех пор, пока не будет найдена свободная ячейка, после чего пара ключ-значение вставляются туда. При поиске значения в хеш-таблице выполняется аналогичный перебор ячеек. Этот перебор завершается, когда искомое значение найдено (ключ совпал по значению), или когда найдена пустая ячейка (в этом случае искомое значение отсутствует). При использовании этого метода разрешения коллизий, операция удаления не может быть выполнена тривиальным образом (поиск значения и его удаление), поскольку такая реализация приведет к досрочном прерыванию перебора при поиске значений по другим ключам, и, как следствие, ложно-отрицательным результатам поиска. Вместо этого ячейки, содержащие удаляемые значения, просто помечаются как удаленные, хранимые ключ и значение уничтожаются. При поиске значения ячейки, помеченные как удаленные, считаются содержащими значение, отличное от искомого; при вставке они считаются свободными.

Хеширование кукушки
-------------------

Идея хеширования кукушки состоит в использовании двух хеш-функций из универсального семейства. Назовем их H1 и H2. В ячейках хеш-таблицы лежат пары ключ-значение. При поиске значения по ключу x проверяются ячейки, соответствующие хешам H1(x) и H2(x), если ни в одной из ячеек искомого значения нет, то это значение в таблице отсутствует. При удалении значения поиск производится аналогично, и удаление также тривиально. Операция добавления значения более сложна.

При добавлении значения с ключом x сначала проверяется, свободна ли ячейка, соответствующая какому-то из хешей H1(x) и H2(x). Если ячейка свободна -- она заполняется новой парой ключ-значение. Если обе ячейки заняты, то из них произвольно выбирается одна, хранящийся в ней элемент запоминается и замещается новым. После этого проверяется, по какому из хешей хранился в ячейке запомненный элемент. Затем этот элемент помещается в ячейку, соответствующую другому хешу (например, если он хранился по ячейке, соответствующей H1(y), то он помещается в ячейку, соответствующую H2(y)). Если эта ячейка занята -- то запоминается элемент, который там хранился, после чего для него повторяется эта же операция. При выполнении операции вставки важно проверять, не произошло ли зацикливание. В случае, если зацикливание произошло, выбираются две новых хеш-функции, и вся хеш-таблица перестраивается для их использования.

Перехеширование
===============

Для обеспечения нормальной работы хеш-таблицы необходима операция перехеширования. Эта операция периодически выполняется во всех описанных выше методах разрешения коллизий. В хешировании кукушки условие, при котором необходимо выполнить перехеширование, заложено в алгоритм добавления нового значения, однако также оно выполняется, когда количество заполненных ячеек таблицы превышает определенную долю от суммарного количества ячеек. При использовании метода цепочек перехеширование имеет смысл, когда в одной из ячеек хранится слишком много пар ключ-значение. При использовании метода открытой адресации перехеширование является необходимым условием работоспособности при увеличении заполняемости таблицы.

Сама по себе операция перехеширования тривиальна: выбирается новая хеш-функция (или несколько хеш-функций), создается новый массив, после чего старые значения переносятся в него. При выборе новой хеш-функции стоит задуматься о том, нужно ли увеличивать пространство ее значений и тем самым снижать долю заполненных ячеек в таблице.

Задание
=======

Необходимо реализовать хеш-таблицу одним из описанных выше способов.

Файлы задания можно скачать отсюда: https://mega.nz/file/WjoUFK6C#CYle1wniSzM0L0f3c5Mw6p2lY76kH3Pa9jTDLnlhbGA . Править можно файлы hashtable.h и hash.h. В файле hashtable.h находится "каркас" самой хеш-таблицы, в файле hash.h -- реализация шаблонной структуры, которая выполняет хеширование. Изначально там реализована специализация для std::string с использованием 64-битной версии хеш-функции MurMurHash2. Стандартная библиотека языка C++ тоже использует MurMur2 в качестве хеш-функции, но с несколько другой реализацией (на самом деле, стандарт C++ не гарантирует, какой алгоритм хеширования используется; в случаях, когда критично сохранение алгоритма следует использовать FNV-хеш, который также реализован в стандартной библиотеке).

Сборка будет осуществляться следующими командами:

.. code :: c++

  g++ -std=c++17 -fsanitize=address,undefined main.cpp -c
  g++ -std=c++17 -fsanitize=address,undefined main.o hashtable.cpp
  
В файле тестов hashtable.cpp есть две секции тестов, защищенные блоком #ifdef. На них пока можно не обращать внимания, они будут темой следующего задания.
