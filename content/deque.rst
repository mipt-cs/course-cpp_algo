Deque (для продвинутой группы по C++)
#####################################

:date: 2020-03-23 09:00
:summary: Deque (для продвинутой группы по C++)
:status: draft

.. default-role:: code
.. contents:: Содержание

Deque
=====

Deque (сокрещение от double ended queue) --- это структура данных, в
которую данные можно добавлять и удалять как из начала, так и из конца.
В этом состоит ее отличие от стека и очереди. Одной из возможных
реализаций дека является обычный двусвязный список, однако у этой
реализации есть важный недостаток: она не может обеспечить константное
время произвольного доступа к элементам.

Дек должен предлагать несколько методов: - push\_back и push\_front для
вставки элементов в голову и хвост, асимптотика О(1) - pop\_back и
pop\_front для удаления из головы и хвоста, асимптотика О(1) -
произвольный доступ к элементам по индексу, асимптотика О(1)

Реализация дека в STL также дает возможность вставки и удаления
элементов в произвольное место с асимптотикой O(N).

Варианты реализации
-------------------

Общие замечания
~~~~~~~~~~~~~~~

Для оптимизации производительности в деке элементы не хранятся по
одному. Вместо этого они хранятся в памяти блоками фиксированного
размера. Пока элементы помещаются в один блок памяти --- новый блок не
выделяется. Каждый блок может быть использован как полностью, так и
частично (в нем может не хватать элементов в конце если это хвостовой
блок или в начале если это головной блок). Следствием из такого способа
хранения данных является тот факт, что указатели на элемент, хранящийся
в деке, не инвалидируются при вставке или удалении нового элемента (как
это, например, происходит с вектором).

Реализация на кольцевом буфере
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Для хранения указателей на элементы дека может использоваться кольцевой
буфер. Фактически этот буфер представляет собой обычным массив, в
котором лежат указатели на заранее выделенные блоки памяти. Реализация
структуры данных хранит номера блоков, являющихся головой и хвостом
очереди. Также хранится смещение нулевого элемента дека относительно
нулевого элемента нулевого блока. Это позволяет зная индекс в деке
вычислять адрес блока в котором хранится нужный элемент и смещение в
нем.

Реализация на двух векторах
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Аналогично использованию кольцевого буфера, можно также использовать два
вектора. В этом случае один из векторов отвечает за хранение указателей
при росте дека в сторону головы, второй - при росте дека в сторону
хвоста. Зная смещение нулевого индекса можно пересчитывать индекс
элемента в деке в "реальный" индекс в блочной структуре.

Изменение размера
-----------------

При добавлении элементов в дек может потребоваться выделение новых
блоков для их хранения. В случае использования двух векторов для
реализации добавление нового блока является тривиальной задачей и
сводится к добавлению нового указателя в соответствующий вектор при
необходимости. В случае использования кольцевого буфера может возникнуть
необходимость выделения нового буфера. Здесь следует поступать
аналогично вектору и увеличивать размер буфера не на константную
величину а в константное число раз.

При уменьшении дека также может возникнуть необходимость освободить
часть блоков для более экономного расходования памяти. В случае
кольцевого буфера изменение размера при увеличении и уменьшении делается
абсолютно аналогично. В случае же двух векторов следует предусмотреть
возможность того, что дек будет использоваться как обычная очередь. Если
не обрабатывать эту ситуацию корректно, то может возникнуть ситуация,
когда и головной и хвостовой блоки имеют индексы одного знака, их
значения велики, и один из двух векторов имеет большой размер, хотя его
первые элементы хранят указатели на блоки, которые уже были очищены (или
эти элементы вовсе не используются). В таком случае возникает
зависимость потребляемой структурой памяти от количества выполненных над
ней операций, а не хранимых элементов, что недопустимо.

Задание
-------

Выбрать один из двух способов (или придумать свой, но асимптотики должны
соблюдаться) и реализовать им дек. Реализация должна быть совместима с
приведенным интерфейсом.

Для тестирования можно использовать файлы из архива:
https://mega.nz/#!zi4FTKIa!CFXkia05Dr83w9G8dISavpxiQ2A8ODNJMEAkxq\_kJK8
Войдя в диреткорию архива для сборки можно использовать следующие
команды:

::

    g++ -std=c++17 -fsanitize=address,undefined main.cpp -c
    g++ -std=c++17 -fsanitize=address,undefined main.o deque.cpp

При изменении в файле deque.h для сборки новой версии достаточно второй
команды.

Разумеется можно не использовать эти тестовые файлы, однако при проверке
задания будут использоваться именно они.

Выполненное задание присылайте на почту stetsyuk[at]phystech.edu или в
Telegram @defective\_bliss. Вопросы можно писать туда же.

deque.h:

::

    template <class T>
    class Deque {
    public:
        Deque() {
            // todo
        }
        
        void PushBack(const T& t) {
            // todo
        }
        void PopBack() {
            // ...
        }
        
        T& Back() {
            // ...
        }
        const T& Back() const {
            // ...
        }
        
        void PushFront(const T& t) {
            // ...
        }
        void PopFront() {
            // ...
        }
        
        T& Front() {
            // ...
        }
        const T& Front() const {
            // ...
        }
        
        size_t Size() const {
            // ...
        }
        
        T& operator[](size_t index) {
            // ...
            
        }
        const T& operator[](size_t index) const {
            // ...
        }
        
        ~Deque() {
            // ...
        }
    private:
        /* Your class - your vars */
    };

Полезные ссылки
---------------

https://ru.cppreference.com/w/cpp/container/deque
http://www.cplusplus.com/reference/deque/deque/
