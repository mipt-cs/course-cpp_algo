Вопросы на зачёт
###################################

:date: 2020-12-14 09:00
:summary: Список вопрос к осеннему зачёту.
:status: draft

.. default-role:: code
.. contents:: Содержание

Времена и даты
==============

Контрольная работа №2 пройдёт 9 декабря с 13:55 до 15:30 во время лекции.
Длительность 1.5 часа.

Все рядовые контесты семестра закрываются 13 декабря в 22:00.

Рейтинговая оценка за работу в семестре, учитывающая все контесты и обе
контрольные работы, окончательно выставляется и публикуется к 9:00 14 декабря.

Дифференцированный зачёт по информатике принимается дистанционно в устной форме
на зачётной неделе с 14 декабря по 19 декабря по индивидуальному расписанию.
Расписание сдач формируется за неделю до зачёта.
Зачёт для одного экзаменуемого длится от 20 до 40 минут.

Порядок сдачи зачёта
====================

Зачёт принимает два экзаменатора. Студент должен отвечать на вопросы без предварительной подготовки.
При случайном или плановом обрыве связи студент получает другой билет.

Студенту для сдачи зачёта необходимо наличие аудио и видео аппаратуры и связь
через сеть Интернет достаточного качества для участия в видеоконференции
через систему Google Meet с эккаунтом `your_username@phystech.edu`.
Также необходимо предварительно зарегистрироваться на сайте repl.it по привязке
к Google-эккаунту с тем же личным эккаунтом `your_username@phystech.edu`.
Конкретная ссылка на конференцию будет переслана по почте.

Оценивание
==========

Рекомендуемая итоговая оценка студента по предмету — это среднее арифметическое
взвешенное оценок по лабораторным работам и контрольным. Экзаменатор видит все
эти оценки по отдельности, а также рекомендуемую итоговую оценку.
Исходя из ответа студента итоговая оценка за зачёт может быть отклонена от
рекомендуемой на ±3 балла (по 10-балльной шкале).
Студент при несогласии с итоговой оценкой может потребовать апелляции, однако на
апелляции оценка может быть и понижена.

Список вопросов к зачёту
========================

Cтудент получает билет, сгенерированный из одной задачи и двух случайных
вопросов — одного по синаксису С++ и другого по алгоритмам и структурам данных.
Задача решается под наблюдением преподавателя в системе repl.it.
При решении задачи важно показать умение рассуждать, выбирать правильные
структуры данных и стандартные контейнеры С++, догадываться какой алгоритм
требуется применить.

Вопросы по синтаксису С++
-------------------------

#. Контейнер std::list. Конструирование, методы добавления и удаления элементов, амортизированная асимптотическая сложность операций.
#. Контейнер std::vector. Конструирование, методы добавления и удаления элементов, амортизированная асимптотическая сложность операций.
#. Контейнер std::set. Контейнер std::map. Конструирование, методы добавления и удаления элементов, амортизированная асимптотическая сложность операций. Порядок обхода элементов итератором, требования к пользовательскому типу для использования в качестве ключа в таблице.
#. Контейнеры std::unordered_set и std::unordered_map, добавление и удаление элементов, порядок обхода элементов итератором, требования к пользовательскому типу для использования в качестве ключа в таблице.
#. Итераторы для работы с контейнерами в C++. Понятие итератора как универсального средства доступа к элементам линейно перечислимого типа данных, цикл по диапазону (range-based-for) и стандартный алгоритм std::for_each.
#. Основы объектного подхода к конструированию кода. Объект как совокупность данных и функций над ними (инкапсуляция), классы и объекты, принцип сокрытия данных, модификаторы доступа public и private и по умолчанию, конструирование и конструктор по умолчанию.
#. Управление ресурсами в C++. Концепция RAII. Что такое ресурс и зачем им нужно управлять. Что такое деструктор. Проблемы с оператором присваивания и копирующим конструктором. “Правило пяти”.
#. Полиморфизм на основе шаблонов. Шаблоны функции. Параметры шаблона. Значения параметров по умолчанию. Отличие шаблонов от обычных функций, генерация на этапе компиляции (инстанцирование), раздувание кода (code flood).
#. Полиморфизм на основе шаблонов. Шаблонные классы. Пример использования шаблона класса.

Вопросы по алгоритмам
---------------------

#. Хеш-функция как сжимающее отображение. Необратимость. Коллизии. Полиномиальный хеш и алгоритм Рабина-Карпа, асимптотическая сложность и выбор параметров полиномиального хеша.
#. Хеш-функция как сжимающее отображение. Коллизии. Использование хеширования в криптографии, для контроля целостности данных. Фильтр Блума для уменьшения обращений к большим объемам данных.
#. Хеш-таблицы. Реализация “множества” и “ассоциативного массива”. Асимптотическая сложность поиска, вставки и удаления. Проблема коллизий, метод цепочек и открытая адресация. Коэффициент заполнения таблицы.Необходимость перехеширования.
#. Бинарные деревья поиска: АВЛ-дерево. Использование бинарных деревьев для реализации множеств и ассоциативных массивов, проблема балансировки и самобалансирующиеся деревья, повороты как преобразования сохраняющие инварианты дерева, принцип балансировки АВЛ-дерева, добавление и удаление элементов.
#. Бинарные деревья поиска: красно-чёрное дерево. Использование бинарных деревьев для реализации множеств и ассоциативных массивов, проблема балансировки и самобалансирующиеся деревья, повороты как преобразования сохраняющие инварианты дерева, принцип балансировки красно-чёрного дерева, добавление и удаление элементов.
#. Понятие конечного автомата. Детерминированный и недетерминированный конечные автоматы. Алгоритм распознавания слова конечным автоматом.
#. Понятие регулярного языка. Представление регулярного языка посредством регулярного выражения, символы-джокеры (\*, ?, + и т.п.). Преобразование детерминированного конечного автомата в регулярное выражение.
#. Определение графа. Степень вершины, петли, кратные рёбра. Изоморфизм. Цепи, пути и циклы. Выделение компонент связности обходом в глубину.
#. Сильная и слабая связность графа. Компоненты связности. Изолированная вершина. Выделение компонент связности обходом в ширину.
#. Определение дерева. Свойства дерева. Остовное дерево графа. Построение минимального остовного дерева. Алгоритм Крускала.
#. Способы представления графа в памяти: список рёбер, матрица смежности, списки смежности.  Топологическая сортировка DAG.
#. Алгоритм Дейкстры. Асимптотическая сложность. Восстановление пути.
#. Алгоритм Флойда-Уоршелла. Асимптотическая сложность. Восстановление пути.
#. Алгоритм Форда-Беллмана. Асимптотическая сложность. Восстановление пути.
#. Обход графа в ширину. Дерево обхода. Проверка двудольности графа.
#. Обход графа в глубину. Дерево обхода. Поиск мостов в графе.


Вопросы на повышение оценки в спорных случаях:
----------------------------------------------
#. Внутренняя структура std::priority_queue: бинарная куча, построение, добавление и удаление максимального/минимального элемента из кучи, сортировка с использованием бинарной кучи (пирамидальная сортировка).
#. Асимптотическая сложность алгоритмов std::find, std::lower_bound и std::upper_bound на неотсортированных и отсортированных данных. Алгоритмы std::sort и std::stable_sort, асимптотическая сложность и асимптотическое потребление памяти, различие алгоритмов. Сортировка списка.
#. Использование const для дополнительного статического контроля. Инициализация неизменяемых внутренних данных (const) и ссылок, различие методов и функций, передача объектов в качестве параметров, методы с модификатором const.
#. Правосторонняя ссылка (r-value reference), конструктор перемещения и оператор перемещающего присваивания, плюсы и минусы управления ресурсами на основе перемещения. Пример использования перемещения.
#. Проблема экспоненциального роста состояний в определенных языках для детерминированных автоматов, алгоритм распознавания для недетерминированных автоматов, эквивалентность множеств языков, заданных автоматами, и регулярных языков.
#. Конечные автоматы и регулярные выражения. Представление регулярного языка посредством регулярного выражения, символы-джокеры (\*, ?, + и т.п.), преобразование регулярного выражения в недетерминированный конечный автомат (алгоритм Томсона), преобразование конечного автомата в регулярное выражение, метод удаления состояний и метод транзитивного закрытия.
#. Минимизация конечного автомата. Проблема алгоритмической неразрешимости эквивалентности двух машин Тьюринга и разрешимость эквивалентности двух конечных автоматов через построение минимального, изоморфные конечные автоматы. Алгоритмы минимизации детерминированных конечных автоматов, классы эквивалентности и k-эквивалентность, транзитивное замыкание таблицы неэквивалентности и алгоритм Хопкрофта.
#. Поиск точек сочленения (шарниров) в графе.
#. Проверка графа на ацикличность или нахождение цикла обходом в глубину.
#. Нахождение кратчайшего цикла в невзвешенном графе.
